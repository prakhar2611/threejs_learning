{
  "version": 3,
  "sources": ["../../heap/lib/heap.js", "../../heap/index.js", "../../pathfinding/src/core/Node.js", "../../pathfinding/src/core/DiagonalMovement.js", "../../pathfinding/src/core/Grid.js", "../../pathfinding/src/core/Util.js", "../../pathfinding/src/core/Heuristic.js", "../../pathfinding/src/finders/AStarFinder.js", "../../pathfinding/src/finders/BestFirstFinder.js", "../../pathfinding/src/finders/BreadthFirstFinder.js", "../../pathfinding/src/finders/DijkstraFinder.js", "../../pathfinding/src/finders/BiAStarFinder.js", "../../pathfinding/src/finders/BiBestFirstFinder.js", "../../pathfinding/src/finders/BiBreadthFirstFinder.js", "../../pathfinding/src/finders/BiDijkstraFinder.js", "../../pathfinding/src/finders/IDAStarFinder.js", "../../pathfinding/src/finders/JumpPointFinderBase.js", "../../pathfinding/src/finders/JPFNeverMoveDiagonally.js", "../../pathfinding/src/finders/JPFAlwaysMoveDiagonally.js", "../../pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js", "../../pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js", "../../pathfinding/src/finders/JumpPointFinder.js", "../../pathfinding/src/PathFinding.js", "../../pathfinding/index.js"],
  "sourcesContent": ["// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n", "module.exports = require('./lib/heap');\n", "/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n", "var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;", "var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // ↑\r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // →\r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // ↓\r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // ←\r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // ↖\r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // ↗\r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // ↘\r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // ↙\r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n", "/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n", "/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n", "var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n", "var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n", "var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n", "var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n", "var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n", "var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n", "var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n", "var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n", "var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n", "/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n", "/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n", "module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n", "module.exports = require('./src/PathFinding');\r\n"],
  "mappings": "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",
  "names": ["_j", "_ref", "Heap", "require_heap", "route", "t"]
}
