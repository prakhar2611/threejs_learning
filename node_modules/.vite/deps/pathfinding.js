import {
  __commonJS
} from "./chunk-Y2F7D3TJ.js";

// node_modules/heap/lib/heap.js
var require_heap = __commonJS({
  "node_modules/heap/lib/heap.js"(exports, module) {
    (function() {
      var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
      floor = Math.floor, min = Math.min;
      defaultCmp = function(x, y) {
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      };
      insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error("lo must be non-negative");
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
      };
      heappush = function(array, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array.push(item);
        return _siftdown(array, 0, array.length - 1, cmp);
      };
      heappop = function(array, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array.pop();
        if (array.length) {
          returnitem = array[0];
          array[0] = lastelt;
          _siftup(array, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      };
      heapreplace = function(array, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array[0];
        array[0] = item;
        _siftup(array, 0, cmp);
        return returnitem;
      };
      heappushpop = function(array, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array.length && cmp(array[0], item) < 0) {
          _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
          _siftup(array, 0, cmp);
        }
        return item;
      };
      heapify = function(array, cmp) {
        var i, _i, _j, _len, _ref, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = (function() {
          _results1 = [];
          for (var _j2 = 0, _ref2 = floor(array.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
            _results1.push(_j2);
          }
          return _results1;
        }).apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(_siftup(array, i, cmp));
        }
        return _results;
      };
      updateItem = function(array, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array, 0, pos, cmp);
        return _siftup(array, pos, cmp);
      };
      nlargest = function(array, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      };
      nsmallest = function(array, n, cmp) {
        var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array.length) {
          result = array.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array, cmp);
        _results = [];
        for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array, cmp));
        }
        return _results;
      };
      _siftdown = function(array, startpos, pos, cmp) {
        var newitem, parent, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array[pos];
        while (pos > startpos) {
          parentpos = pos - 1 >> 1;
          parent = array[parentpos];
          if (cmp(newitem, parent) < 0) {
            array[pos] = parent;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array[pos] = newitem;
      };
      _siftup = function(array, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array.length;
        startpos = pos;
        newitem = array[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array[pos] = array[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array[pos] = newitem;
        return _siftdown(array, startpos, pos, cmp);
      };
      Heap = function() {
        Heap2.push = heappush;
        Heap2.pop = heappop;
        Heap2.replace = heapreplace;
        Heap2.pushpop = heappushpop;
        Heap2.heapify = heapify;
        Heap2.updateItem = updateItem;
        Heap2.nlargest = nlargest;
        Heap2.nsmallest = nsmallest;
        function Heap2(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }
        Heap2.prototype.push = function(x) {
          return heappush(this.nodes, x, this.cmp);
        };
        Heap2.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };
        Heap2.prototype.peek = function() {
          return this.nodes[0];
        };
        Heap2.prototype.contains = function(x) {
          return this.nodes.indexOf(x) !== -1;
        };
        Heap2.prototype.replace = function(x) {
          return heapreplace(this.nodes, x, this.cmp);
        };
        Heap2.prototype.pushpop = function(x) {
          return heappushpop(this.nodes, x, this.cmp);
        };
        Heap2.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };
        Heap2.prototype.updateItem = function(x) {
          return updateItem(this.nodes, x, this.cmp);
        };
        Heap2.prototype.clear = function() {
          return this.nodes = [];
        };
        Heap2.prototype.empty = function() {
          return this.nodes.length === 0;
        };
        Heap2.prototype.size = function() {
          return this.nodes.length;
        };
        Heap2.prototype.clone = function() {
          var heap;
          heap = new Heap2();
          heap.nodes = this.nodes.slice(0);
          return heap;
        };
        Heap2.prototype.toArray = function() {
          return this.nodes.slice(0);
        };
        Heap2.prototype.insert = Heap2.prototype.push;
        Heap2.prototype.top = Heap2.prototype.peek;
        Heap2.prototype.front = Heap2.prototype.peek;
        Heap2.prototype.has = Heap2.prototype.contains;
        Heap2.prototype.copy = Heap2.prototype.clone;
        return Heap2;
      }();
      if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
        module.exports = Heap;
      } else {
        window.Heap = Heap;
      }
    }).call(exports);
  }
});

// node_modules/heap/index.js
var require_heap2 = __commonJS({
  "node_modules/heap/index.js"(exports, module) {
    module.exports = require_heap();
  }
});

// node_modules/pathfinding/src/core/Node.js
var require_Node = __commonJS({
  "node_modules/pathfinding/src/core/Node.js"(exports, module) {
    function Node(x, y, walkable) {
      this.x = x;
      this.y = y;
      this.walkable = walkable === void 0 ? true : walkable;
    }
    module.exports = Node;
  }
});

// node_modules/pathfinding/src/core/DiagonalMovement.js
var require_DiagonalMovement = __commonJS({
  "node_modules/pathfinding/src/core/DiagonalMovement.js"(exports, module) {
    var DiagonalMovement = {
      Always: 1,
      Never: 2,
      IfAtMostOneObstacle: 3,
      OnlyWhenNoObstacles: 4
    };
    module.exports = DiagonalMovement;
  }
});

// node_modules/pathfinding/src/core/Grid.js
var require_Grid = __commonJS({
  "node_modules/pathfinding/src/core/Grid.js"(exports, module) {
    var Node = require_Node();
    var DiagonalMovement = require_DiagonalMovement();
    function Grid(width_or_matrix, height, matrix) {
      var width;
      if (typeof width_or_matrix !== "object") {
        width = width_or_matrix;
      } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
      }
      this.width = width;
      this.height = height;
      this.nodes = this._buildNodes(width, height, matrix);
    }
    Grid.prototype._buildNodes = function(width, height, matrix) {
      var i, j, nodes = new Array(height);
      for (i = 0; i < height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
          nodes[i][j] = new Node(j, i);
        }
      }
      if (matrix === void 0) {
        return nodes;
      }
      if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error("Matrix size does not fit");
      }
      for (i = 0; i < height; ++i) {
        for (j = 0; j < width; ++j) {
          if (matrix[i][j]) {
            nodes[i][j].walkable = false;
          }
        }
      }
      return nodes;
    };
    Grid.prototype.getNodeAt = function(x, y) {
      return this.nodes[y][x];
    };
    Grid.prototype.isWalkableAt = function(x, y) {
      return this.isInside(x, y) && this.nodes[y][x].walkable;
    };
    Grid.prototype.isInside = function(x, y) {
      return x >= 0 && x < this.width && (y >= 0 && y < this.height);
    };
    Grid.prototype.setWalkableAt = function(x, y, walkable) {
      this.nodes[y][x].walkable = walkable;
    };
    Grid.prototype.getNeighbors = function(node, diagonalMovement) {
      var x = node.x, y = node.y, neighbors = [], s0 = false, d0 = false, s1 = false, d1 = false, s2 = false, d2 = false, s3 = false, d3 = false, nodes = this.nodes;
      if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(nodes[y - 1][x]);
        s0 = true;
      }
      if (this.isWalkableAt(x + 1, y)) {
        neighbors.push(nodes[y][x + 1]);
        s1 = true;
      }
      if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(nodes[y + 1][x]);
        s2 = true;
      }
      if (this.isWalkableAt(x - 1, y)) {
        neighbors.push(nodes[y][x - 1]);
        s3 = true;
      }
      if (diagonalMovement === DiagonalMovement.Never) {
        return neighbors;
      }
      if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
      } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
      } else if (diagonalMovement === DiagonalMovement.Always) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
      } else {
        throw new Error("Incorrect value of diagonalMovement");
      }
      if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push(nodes[y - 1][x - 1]);
      }
      if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push(nodes[y - 1][x + 1]);
      }
      if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push(nodes[y + 1][x + 1]);
      }
      if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push(nodes[y + 1][x - 1]);
      }
      return neighbors;
    };
    Grid.prototype.clone = function() {
      var i, j, width = this.width, height = this.height, thisNodes = this.nodes, newGrid = new Grid(width, height), newNodes = new Array(height);
      for (i = 0; i < height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
          newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
      }
      newGrid.nodes = newNodes;
      return newGrid;
    };
    module.exports = Grid;
  }
});

// node_modules/pathfinding/src/core/Util.js
var require_Util = __commonJS({
  "node_modules/pathfinding/src/core/Util.js"(exports) {
    function backtrace(node) {
      var path = [[node.x, node.y]];
      while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
      }
      return path.reverse();
    }
    exports.backtrace = backtrace;
    function biBacktrace(nodeA, nodeB) {
      var pathA = backtrace(nodeA), pathB = backtrace(nodeB);
      return pathA.concat(pathB.reverse());
    }
    exports.biBacktrace = biBacktrace;
    function pathLength(path) {
      var i, sum = 0, a, b, dx, dy;
      for (i = 1; i < path.length; ++i) {
        a = path[i - 1];
        b = path[i];
        dx = a[0] - b[0];
        dy = a[1] - b[1];
        sum += Math.sqrt(dx * dx + dy * dy);
      }
      return sum;
    }
    exports.pathLength = pathLength;
    function interpolate(x0, y0, x1, y1) {
      var abs = Math.abs, line = [], sx, sy, dx, dy, err, e2;
      dx = abs(x1 - x0);
      dy = abs(y1 - y0);
      sx = x0 < x1 ? 1 : -1;
      sy = y0 < y1 ? 1 : -1;
      err = dx - dy;
      while (true) {
        line.push([x0, y0]);
        if (x0 === x1 && y0 === y1) {
          break;
        }
        e2 = 2 * err;
        if (e2 > -dy) {
          err = err - dy;
          x0 = x0 + sx;
        }
        if (e2 < dx) {
          err = err + dx;
          y0 = y0 + sy;
        }
      }
      return line;
    }
    exports.interpolate = interpolate;
    function expandPath(path) {
      var expanded = [], len = path.length, coord0, coord1, interpolated, interpolatedLen, i, j;
      if (len < 2) {
        return expanded;
      }
      for (i = 0; i < len - 1; ++i) {
        coord0 = path[i];
        coord1 = path[i + 1];
        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
        interpolatedLen = interpolated.length;
        for (j = 0; j < interpolatedLen - 1; ++j) {
          expanded.push(interpolated[j]);
        }
      }
      expanded.push(path[len - 1]);
      return expanded;
    }
    exports.expandPath = expandPath;
    function smoothenPath(grid, path) {
      var len = path.length, x0 = path[0][0], y0 = path[0][1], x1 = path[len - 1][0], y1 = path[len - 1][1], sx, sy, ex, ey, newPath, i, j, coord, line, testCoord, blocked;
      sx = x0;
      sy = y0;
      newPath = [[sx, sy]];
      for (i = 2; i < len; ++i) {
        coord = path[i];
        ex = coord[0];
        ey = coord[1];
        line = interpolate(sx, sy, ex, ey);
        blocked = false;
        for (j = 1; j < line.length; ++j) {
          testCoord = line[j];
          if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
            blocked = true;
            break;
          }
        }
        if (blocked) {
          lastValidCoord = path[i - 1];
          newPath.push(lastValidCoord);
          sx = lastValidCoord[0];
          sy = lastValidCoord[1];
        }
      }
      newPath.push([x1, y1]);
      return newPath;
    }
    exports.smoothenPath = smoothenPath;
    function compressPath(path) {
      if (path.length < 3) {
        return path;
      }
      var compressed = [], sx = path[0][0], sy = path[0][1], px = path[1][0], py = path[1][1], dx = px - sx, dy = py - sy, lx, ly, ldx, ldy, sq, i;
      sq = Math.sqrt(dx * dx + dy * dy);
      dx /= sq;
      dy /= sq;
      compressed.push([sx, sy]);
      for (i = 2; i < path.length; i++) {
        lx = px;
        ly = py;
        ldx = dx;
        ldy = dy;
        px = path[i][0];
        py = path[i][1];
        dx = px - lx;
        dy = py - ly;
        sq = Math.sqrt(dx * dx + dy * dy);
        dx /= sq;
        dy /= sq;
        if (dx !== ldx || dy !== ldy) {
          compressed.push([lx, ly]);
        }
      }
      compressed.push([px, py]);
      return compressed;
    }
    exports.compressPath = compressPath;
  }
});

// node_modules/pathfinding/src/core/Heuristic.js
var require_Heuristic = __commonJS({
  "node_modules/pathfinding/src/core/Heuristic.js"(exports, module) {
    module.exports = {
      /**
       * Manhattan distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} dx + dy
       */
      manhattan: function(dx, dy) {
        return dx + dy;
      },
      /**
       * Euclidean distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} sqrt(dx * dx + dy * dy)
       */
      euclidean: function(dx, dy) {
        return Math.sqrt(dx * dx + dy * dy);
      },
      /**
       * Octile distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} sqrt(dx * dx + dy * dy) for grids
       */
      octile: function(dx, dy) {
        var F = Math.SQRT2 - 1;
        return dx < dy ? F * dx + dy : F * dy + dx;
      },
      /**
       * Chebyshev distance.
       * @param {number} dx - Difference in x.
       * @param {number} dy - Difference in y.
       * @return {number} max(dx, dy)
       */
      chebyshev: function(dx, dy) {
        return Math.max(dx, dy);
      }
    };
  }
});

// node_modules/pathfinding/src/finders/AStarFinder.js
var require_AStarFinder = __commonJS({
  "node_modules/pathfinding/src/finders/AStarFinder.js"(exports, module) {
    var Heap = require_heap2();
    var Util = require_Util();
    var Heuristic = require_Heuristic();
    var DiagonalMovement = require_DiagonalMovement();
    function AStarFinder(opt) {
      opt = opt || {};
      this.allowDiagonal = opt.allowDiagonal;
      this.dontCrossCorners = opt.dontCrossCorners;
      this.heuristic = opt.heuristic || Heuristic.manhattan;
      this.weight = opt.weight || 1;
      this.diagonalMovement = opt.diagonalMovement;
      if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
          this.diagonalMovement = DiagonalMovement.Never;
        } else {
          if (this.dontCrossCorners) {
            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
          } else {
            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
          }
        }
      }
      if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
      } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
      }
    }
    AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
      var openList = new Heap(function(nodeA, nodeB) {
        return nodeA.f - nodeB.f;
      }), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i, l, x, y, ng;
      startNode.g = 0;
      startNode.f = 0;
      openList.push(startNode);
      startNode.opened = true;
      while (!openList.empty()) {
        node = openList.pop();
        node.closed = true;
        if (node === endNode) {
          return Util.backtrace(endNode);
        }
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
          neighbor = neighbors[i];
          if (neighbor.closed) {
            continue;
          }
          x = neighbor.x;
          y = neighbor.y;
          ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2);
          if (!neighbor.opened || ng < neighbor.g) {
            neighbor.g = ng;
            neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.parent = node;
            if (!neighbor.opened) {
              openList.push(neighbor);
              neighbor.opened = true;
            } else {
              openList.updateItem(neighbor);
            }
          }
        }
      }
      return [];
    };
    module.exports = AStarFinder;
  }
});

// node_modules/pathfinding/src/finders/BestFirstFinder.js
var require_BestFirstFinder = __commonJS({
  "node_modules/pathfinding/src/finders/BestFirstFinder.js"(exports, module) {
    var AStarFinder = require_AStarFinder();
    function BestFirstFinder(opt) {
      AStarFinder.call(this, opt);
      var orig = this.heuristic;
      this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1e6;
      };
    }
    BestFirstFinder.prototype = new AStarFinder();
    BestFirstFinder.prototype.constructor = BestFirstFinder;
    module.exports = BestFirstFinder;
  }
});

// node_modules/pathfinding/src/finders/BreadthFirstFinder.js
var require_BreadthFirstFinder = __commonJS({
  "node_modules/pathfinding/src/finders/BreadthFirstFinder.js"(exports, module) {
    var Util = require_Util();
    var DiagonalMovement = require_DiagonalMovement();
    function BreadthFirstFinder(opt) {
      opt = opt || {};
      this.allowDiagonal = opt.allowDiagonal;
      this.dontCrossCorners = opt.dontCrossCorners;
      this.diagonalMovement = opt.diagonalMovement;
      if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
          this.diagonalMovement = DiagonalMovement.Never;
        } else {
          if (this.dontCrossCorners) {
            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
          } else {
            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
          }
        }
      }
    }
    BreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
      var openList = [], diagonalMovement = this.diagonalMovement, startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), neighbors, neighbor, node, i, l;
      openList.push(startNode);
      startNode.opened = true;
      while (openList.length) {
        node = openList.shift();
        node.closed = true;
        if (node === endNode) {
          return Util.backtrace(endNode);
        }
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
          neighbor = neighbors[i];
          if (neighbor.closed || neighbor.opened) {
            continue;
          }
          openList.push(neighbor);
          neighbor.opened = true;
          neighbor.parent = node;
        }
      }
      return [];
    };
    module.exports = BreadthFirstFinder;
  }
});

// node_modules/pathfinding/src/finders/DijkstraFinder.js
var require_DijkstraFinder = __commonJS({
  "node_modules/pathfinding/src/finders/DijkstraFinder.js"(exports, module) {
    var AStarFinder = require_AStarFinder();
    function DijkstraFinder(opt) {
      AStarFinder.call(this, opt);
      this.heuristic = function(dx, dy) {
        return 0;
      };
    }
    DijkstraFinder.prototype = new AStarFinder();
    DijkstraFinder.prototype.constructor = DijkstraFinder;
    module.exports = DijkstraFinder;
  }
});

// node_modules/pathfinding/src/finders/BiAStarFinder.js
var require_BiAStarFinder = __commonJS({
  "node_modules/pathfinding/src/finders/BiAStarFinder.js"(exports, module) {
    var Heap = require_heap2();
    var Util = require_Util();
    var Heuristic = require_Heuristic();
    var DiagonalMovement = require_DiagonalMovement();
    function BiAStarFinder(opt) {
      opt = opt || {};
      this.allowDiagonal = opt.allowDiagonal;
      this.dontCrossCorners = opt.dontCrossCorners;
      this.diagonalMovement = opt.diagonalMovement;
      this.heuristic = opt.heuristic || Heuristic.manhattan;
      this.weight = opt.weight || 1;
      if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
          this.diagonalMovement = DiagonalMovement.Never;
        } else {
          if (this.dontCrossCorners) {
            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
          } else {
            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
          }
        }
      }
      if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
      } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
      }
    }
    BiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
      var cmp = function(nodeA, nodeB) {
        return nodeA.f - nodeB.f;
      }, startOpenList = new Heap(cmp), endOpenList = new Heap(cmp), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i, l, x, y, ng, BY_START = 1, BY_END = 2;
      startNode.g = 0;
      startNode.f = 0;
      startOpenList.push(startNode);
      startNode.opened = BY_START;
      endNode.g = 0;
      endNode.f = 0;
      endOpenList.push(endNode);
      endNode.opened = BY_END;
      while (!startOpenList.empty() && !endOpenList.empty()) {
        node = startOpenList.pop();
        node.closed = true;
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
          neighbor = neighbors[i];
          if (neighbor.closed) {
            continue;
          }
          if (neighbor.opened === BY_END) {
            return Util.biBacktrace(node, neighbor);
          }
          x = neighbor.x;
          y = neighbor.y;
          ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2);
          if (!neighbor.opened || ng < neighbor.g) {
            neighbor.g = ng;
            neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.parent = node;
            if (!neighbor.opened) {
              startOpenList.push(neighbor);
              neighbor.opened = BY_START;
            } else {
              startOpenList.updateItem(neighbor);
            }
          }
        }
        node = endOpenList.pop();
        node.closed = true;
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
          neighbor = neighbors[i];
          if (neighbor.closed) {
            continue;
          }
          if (neighbor.opened === BY_START) {
            return Util.biBacktrace(neighbor, node);
          }
          x = neighbor.x;
          y = neighbor.y;
          ng = node.g + (x - node.x === 0 || y - node.y === 0 ? 1 : SQRT2);
          if (!neighbor.opened || ng < neighbor.g) {
            neighbor.g = ng;
            neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));
            neighbor.f = neighbor.g + neighbor.h;
            neighbor.parent = node;
            if (!neighbor.opened) {
              endOpenList.push(neighbor);
              neighbor.opened = BY_END;
            } else {
              endOpenList.updateItem(neighbor);
            }
          }
        }
      }
      return [];
    };
    module.exports = BiAStarFinder;
  }
});

// node_modules/pathfinding/src/finders/BiBestFirstFinder.js
var require_BiBestFirstFinder = __commonJS({
  "node_modules/pathfinding/src/finders/BiBestFirstFinder.js"(exports, module) {
    var BiAStarFinder = require_BiAStarFinder();
    function BiBestFirstFinder(opt) {
      BiAStarFinder.call(this, opt);
      var orig = this.heuristic;
      this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1e6;
      };
    }
    BiBestFirstFinder.prototype = new BiAStarFinder();
    BiBestFirstFinder.prototype.constructor = BiBestFirstFinder;
    module.exports = BiBestFirstFinder;
  }
});

// node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js
var require_BiBreadthFirstFinder = __commonJS({
  "node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js"(exports, module) {
    var Util = require_Util();
    var DiagonalMovement = require_DiagonalMovement();
    function BiBreadthFirstFinder(opt) {
      opt = opt || {};
      this.allowDiagonal = opt.allowDiagonal;
      this.dontCrossCorners = opt.dontCrossCorners;
      this.diagonalMovement = opt.diagonalMovement;
      if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
          this.diagonalMovement = DiagonalMovement.Never;
        } else {
          if (this.dontCrossCorners) {
            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
          } else {
            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
          }
        }
      }
    }
    BiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
      var startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), startOpenList = [], endOpenList = [], neighbors, neighbor, node, diagonalMovement = this.diagonalMovement, BY_START = 0, BY_END = 1, i, l;
      startOpenList.push(startNode);
      startNode.opened = true;
      startNode.by = BY_START;
      endOpenList.push(endNode);
      endNode.opened = true;
      endNode.by = BY_END;
      while (startOpenList.length && endOpenList.length) {
        node = startOpenList.shift();
        node.closed = true;
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
          neighbor = neighbors[i];
          if (neighbor.closed) {
            continue;
          }
          if (neighbor.opened) {
            if (neighbor.by === BY_END) {
              return Util.biBacktrace(node, neighbor);
            }
            continue;
          }
          startOpenList.push(neighbor);
          neighbor.parent = node;
          neighbor.opened = true;
          neighbor.by = BY_START;
        }
        node = endOpenList.shift();
        node.closed = true;
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i < l; ++i) {
          neighbor = neighbors[i];
          if (neighbor.closed) {
            continue;
          }
          if (neighbor.opened) {
            if (neighbor.by === BY_START) {
              return Util.biBacktrace(neighbor, node);
            }
            continue;
          }
          endOpenList.push(neighbor);
          neighbor.parent = node;
          neighbor.opened = true;
          neighbor.by = BY_END;
        }
      }
      return [];
    };
    module.exports = BiBreadthFirstFinder;
  }
});

// node_modules/pathfinding/src/finders/BiDijkstraFinder.js
var require_BiDijkstraFinder = __commonJS({
  "node_modules/pathfinding/src/finders/BiDijkstraFinder.js"(exports, module) {
    var BiAStarFinder = require_BiAStarFinder();
    function BiDijkstraFinder(opt) {
      BiAStarFinder.call(this, opt);
      this.heuristic = function(dx, dy) {
        return 0;
      };
    }
    BiDijkstraFinder.prototype = new BiAStarFinder();
    BiDijkstraFinder.prototype.constructor = BiDijkstraFinder;
    module.exports = BiDijkstraFinder;
  }
});

// node_modules/pathfinding/src/finders/IDAStarFinder.js
var require_IDAStarFinder = __commonJS({
  "node_modules/pathfinding/src/finders/IDAStarFinder.js"(exports, module) {
    var Util = require_Util();
    var Heuristic = require_Heuristic();
    var Node = require_Node();
    var DiagonalMovement = require_DiagonalMovement();
    function IDAStarFinder(opt) {
      opt = opt || {};
      this.allowDiagonal = opt.allowDiagonal;
      this.dontCrossCorners = opt.dontCrossCorners;
      this.diagonalMovement = opt.diagonalMovement;
      this.heuristic = opt.heuristic || Heuristic.manhattan;
      this.weight = opt.weight || 1;
      this.trackRecursion = opt.trackRecursion || false;
      this.timeLimit = opt.timeLimit || Infinity;
      if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
          this.diagonalMovement = DiagonalMovement.Never;
        } else {
          if (this.dontCrossCorners) {
            this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
          } else {
            this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
          }
        }
      }
      if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
      } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
      }
    }
    IDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
      var nodesVisited = 0;
      var startTime = (/* @__PURE__ */ new Date()).getTime();
      var h = (function(a, b) {
        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
      }).bind(this);
      var cost = function(a, b) {
        return a.x === b.x || a.y === b.y ? 1 : Math.SQRT2;
      };
      var search = (function(node, g, cutoff, route2, depth) {
        nodesVisited++;
        if (this.timeLimit > 0 && (/* @__PURE__ */ new Date()).getTime() - startTime > this.timeLimit * 1e3) {
          return Infinity;
        }
        var f = g + h(node, end) * this.weight;
        if (f > cutoff) {
          return f;
        }
        if (node == end) {
          route2[depth] = [node.x, node.y];
          return node;
        }
        var min, t2, k, neighbour;
        var neighbours = grid.getNeighbors(node, this.diagonalMovement);
        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
          if (this.trackRecursion) {
            neighbour.retainCount = neighbour.retainCount + 1 || 1;
            if (neighbour.tested !== true) {
              neighbour.tested = true;
            }
          }
          t2 = search(neighbour, g + cost(node, neighbour), cutoff, route2, depth + 1);
          if (t2 instanceof Node) {
            route2[depth] = [node.x, node.y];
            return t2;
          }
          if (this.trackRecursion && --neighbour.retainCount === 0) {
            neighbour.tested = false;
          }
          if (t2 < min) {
            min = t2;
          }
        }
        return min;
      }).bind(this);
      var start = grid.getNodeAt(startX, startY);
      var end = grid.getNodeAt(endX, endY);
      var cutOff = h(start, end);
      var j, route, t;
      for (j = 0; true; ++j) {
        route = [];
        t = search(start, 0, cutOff, route, 0);
        if (t === Infinity) {
          return [];
        }
        if (t instanceof Node) {
          return route;
        }
        cutOff = t;
      }
      return [];
    };
    module.exports = IDAStarFinder;
  }
});

// node_modules/pathfinding/src/finders/JumpPointFinderBase.js
var require_JumpPointFinderBase = __commonJS({
  "node_modules/pathfinding/src/finders/JumpPointFinderBase.js"(exports, module) {
    var Heap = require_heap2();
    var Util = require_Util();
    var Heuristic = require_Heuristic();
    var DiagonalMovement = require_DiagonalMovement();
    function JumpPointFinderBase(opt) {
      opt = opt || {};
      this.heuristic = opt.heuristic || Heuristic.manhattan;
      this.trackJumpRecursion = opt.trackJumpRecursion || false;
    }
    JumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {
      var openList = this.openList = new Heap(function(nodeA, nodeB) {
        return nodeA.f - nodeB.f;
      }), startNode = this.startNode = grid.getNodeAt(startX, startY), endNode = this.endNode = grid.getNodeAt(endX, endY), node;
      this.grid = grid;
      startNode.g = 0;
      startNode.f = 0;
      openList.push(startNode);
      startNode.opened = true;
      while (!openList.empty()) {
        node = openList.pop();
        node.closed = true;
        if (node === endNode) {
          return Util.expandPath(Util.backtrace(endNode));
        }
        this._identifySuccessors(node);
      }
      return [];
    };
    JumpPointFinderBase.prototype._identifySuccessors = function(node) {
      var grid = this.grid, heuristic = this.heuristic, openList = this.openList, endX = this.endNode.x, endY = this.endNode.y, neighbors, neighbor, jumpPoint, i, l, x = node.x, y = node.y, jx, jy, dx, dy, d, ng, jumpNode, abs = Math.abs, max = Math.max;
      neighbors = this._findNeighbors(node);
      for (i = 0, l = neighbors.length; i < l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {
          jx = jumpPoint[0];
          jy = jumpPoint[1];
          jumpNode = grid.getNodeAt(jx, jy);
          if (jumpNode.closed) {
            continue;
          }
          d = Heuristic.octile(abs(jx - x), abs(jy - y));
          ng = node.g + d;
          if (!jumpNode.opened || ng < jumpNode.g) {
            jumpNode.g = ng;
            jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
            jumpNode.f = jumpNode.g + jumpNode.h;
            jumpNode.parent = node;
            if (!jumpNode.opened) {
              openList.push(jumpNode);
              jumpNode.opened = true;
            } else {
              openList.updateItem(jumpNode);
            }
          }
        }
      }
    };
    module.exports = JumpPointFinderBase;
  }
});

// node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js
var require_JPFNeverMoveDiagonally = __commonJS({
  "node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js"(exports, module) {
    var JumpPointFinderBase = require_JumpPointFinderBase();
    var DiagonalMovement = require_DiagonalMovement();
    function JPFNeverMoveDiagonally(opt) {
      JumpPointFinderBase.call(this, opt);
    }
    JPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();
    JPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;
    JPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {
      var grid = this.grid, dx = x - px, dy = y - py;
      if (!grid.isWalkableAt(x, y)) {
        return null;
      }
      if (this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
      }
      if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
      }
      if (dx !== 0) {
        if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {
          return [x, y];
        }
      } else if (dy !== 0) {
        if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {
          return [x, y];
        }
        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
          return [x, y];
        }
      } else {
        throw new Error("Only horizontal and vertical movements are allowed");
      }
      return this._jump(x + dx, y + dy, x, y);
    };
    JPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {
      var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i, l;
      if (parent) {
        px = parent.x;
        py = parent.y;
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);
        if (dx !== 0) {
          if (grid.isWalkableAt(x, y - 1)) {
            neighbors.push([x, y - 1]);
          }
          if (grid.isWalkableAt(x, y + 1)) {
            neighbors.push([x, y + 1]);
          }
          if (grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y]);
          }
        } else if (dy !== 0) {
          if (grid.isWalkableAt(x - 1, y)) {
            neighbors.push([x - 1, y]);
          }
          if (grid.isWalkableAt(x + 1, y)) {
            neighbors.push([x + 1, y]);
          }
          if (grid.isWalkableAt(x, y + dy)) {
            neighbors.push([x, y + dy]);
          }
        }
      } else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
          neighborNode = neighborNodes[i];
          neighbors.push([neighborNode.x, neighborNode.y]);
        }
      }
      return neighbors;
    };
    module.exports = JPFNeverMoveDiagonally;
  }
});

// node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js
var require_JPFAlwaysMoveDiagonally = __commonJS({
  "node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js"(exports, module) {
    var JumpPointFinderBase = require_JumpPointFinderBase();
    var DiagonalMovement = require_DiagonalMovement();
    function JPFAlwaysMoveDiagonally(opt) {
      JumpPointFinderBase.call(this, opt);
    }
    JPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();
    JPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;
    JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
      var grid = this.grid, dx = x - px, dy = y - py;
      if (!grid.isWalkableAt(x, y)) {
        return null;
      }
      if (this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
      }
      if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
      }
      if (dx !== 0 && dy !== 0) {
        if (grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y) || grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy)) {
          return [x, y];
        }
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
          return [x, y];
        }
      } else {
        if (dx !== 0) {
          if (grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1) || grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1)) {
            return [x, y];
          }
        } else {
          if (grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y) || grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y)) {
            return [x, y];
          }
        }
      }
      return this._jump(x + dx, y + dy, x, y);
    };
    JPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {
      var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i, l;
      if (parent) {
        px = parent.x;
        py = parent.y;
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);
        if (dx !== 0 && dy !== 0) {
          if (grid.isWalkableAt(x, y + dy)) {
            neighbors.push([x, y + dy]);
          }
          if (grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y]);
          }
          if (grid.isWalkableAt(x + dx, y + dy)) {
            neighbors.push([x + dx, y + dy]);
          }
          if (!grid.isWalkableAt(x - dx, y)) {
            neighbors.push([x - dx, y + dy]);
          }
          if (!grid.isWalkableAt(x, y - dy)) {
            neighbors.push([x + dx, y - dy]);
          }
        } else {
          if (dx === 0) {
            if (grid.isWalkableAt(x, y + dy)) {
              neighbors.push([x, y + dy]);
            }
            if (!grid.isWalkableAt(x + 1, y)) {
              neighbors.push([x + 1, y + dy]);
            }
            if (!grid.isWalkableAt(x - 1, y)) {
              neighbors.push([x - 1, y + dy]);
            }
          } else {
            if (grid.isWalkableAt(x + dx, y)) {
              neighbors.push([x + dx, y]);
            }
            if (!grid.isWalkableAt(x, y + 1)) {
              neighbors.push([x + dx, y + 1]);
            }
            if (!grid.isWalkableAt(x, y - 1)) {
              neighbors.push([x + dx, y - 1]);
            }
          }
        }
      } else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
          neighborNode = neighborNodes[i];
          neighbors.push([neighborNode.x, neighborNode.y]);
        }
      }
      return neighbors;
    };
    module.exports = JPFAlwaysMoveDiagonally;
  }
});

// node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js
var require_JPFMoveDiagonallyIfNoObstacles = __commonJS({
  "node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js"(exports, module) {
    var JumpPointFinderBase = require_JumpPointFinderBase();
    var DiagonalMovement = require_DiagonalMovement();
    function JPFMoveDiagonallyIfNoObstacles(opt) {
      JumpPointFinderBase.call(this, opt);
    }
    JPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();
    JPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;
    JPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {
      var grid = this.grid, dx = x - px, dy = y - py;
      if (!grid.isWalkableAt(x, y)) {
        return null;
      }
      if (this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
      }
      if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
      }
      if (dx !== 0 && dy !== 0) {
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
          return [x, y];
        }
      } else {
        if (dx !== 0) {
          if (grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1) || grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1)) {
            return [x, y];
          }
        } else if (dy !== 0) {
          if (grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy) || grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy)) {
            return [x, y];
          }
        }
      }
      if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
      } else {
        return null;
      }
    };
    JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {
      var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i, l;
      if (parent) {
        px = parent.x;
        py = parent.y;
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);
        if (dx !== 0 && dy !== 0) {
          if (grid.isWalkableAt(x, y + dy)) {
            neighbors.push([x, y + dy]);
          }
          if (grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y]);
          }
          if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y + dy]);
          }
        } else {
          var isNextWalkable;
          if (dx !== 0) {
            isNextWalkable = grid.isWalkableAt(x + dx, y);
            var isTopWalkable = grid.isWalkableAt(x, y + 1);
            var isBottomWalkable = grid.isWalkableAt(x, y - 1);
            if (isNextWalkable) {
              neighbors.push([x + dx, y]);
              if (isTopWalkable) {
                neighbors.push([x + dx, y + 1]);
              }
              if (isBottomWalkable) {
                neighbors.push([x + dx, y - 1]);
              }
            }
            if (isTopWalkable) {
              neighbors.push([x, y + 1]);
            }
            if (isBottomWalkable) {
              neighbors.push([x, y - 1]);
            }
          } else if (dy !== 0) {
            isNextWalkable = grid.isWalkableAt(x, y + dy);
            var isRightWalkable = grid.isWalkableAt(x + 1, y);
            var isLeftWalkable = grid.isWalkableAt(x - 1, y);
            if (isNextWalkable) {
              neighbors.push([x, y + dy]);
              if (isRightWalkable) {
                neighbors.push([x + 1, y + dy]);
              }
              if (isLeftWalkable) {
                neighbors.push([x - 1, y + dy]);
              }
            }
            if (isRightWalkable) {
              neighbors.push([x + 1, y]);
            }
            if (isLeftWalkable) {
              neighbors.push([x - 1, y]);
            }
          }
        }
      } else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
          neighborNode = neighborNodes[i];
          neighbors.push([neighborNode.x, neighborNode.y]);
        }
      }
      return neighbors;
    };
    module.exports = JPFMoveDiagonallyIfNoObstacles;
  }
});

// node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js
var require_JPFMoveDiagonallyIfAtMostOneObstacle = __commonJS({
  "node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js"(exports, module) {
    var JumpPointFinderBase = require_JumpPointFinderBase();
    var DiagonalMovement = require_DiagonalMovement();
    function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
      JumpPointFinderBase.call(this, opt);
    }
    JPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();
    JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;
    JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {
      var grid = this.grid, dx = x - px, dy = y - py;
      if (!grid.isWalkableAt(x, y)) {
        return null;
      }
      if (this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
      }
      if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
      }
      if (dx !== 0 && dy !== 0) {
        if (grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y) || grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy)) {
          return [x, y];
        }
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
          return [x, y];
        }
      } else {
        if (dx !== 0) {
          if (grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1) || grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1)) {
            return [x, y];
          }
        } else {
          if (grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y) || grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y)) {
            return [x, y];
          }
        }
      }
      if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
      } else {
        return null;
      }
    };
    JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {
      var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px, py, nx, ny, dx, dy, neighbors = [], neighborNodes, neighborNode, i, l;
      if (parent) {
        px = parent.x;
        py = parent.y;
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);
        if (dx !== 0 && dy !== 0) {
          if (grid.isWalkableAt(x, y + dy)) {
            neighbors.push([x, y + dy]);
          }
          if (grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y]);
          }
          if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y + dy]);
          }
          if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
            neighbors.push([x - dx, y + dy]);
          }
          if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
            neighbors.push([x + dx, y - dy]);
          }
        } else {
          if (dx === 0) {
            if (grid.isWalkableAt(x, y + dy)) {
              neighbors.push([x, y + dy]);
              if (!grid.isWalkableAt(x + 1, y)) {
                neighbors.push([x + 1, y + dy]);
              }
              if (!grid.isWalkableAt(x - 1, y)) {
                neighbors.push([x - 1, y + dy]);
              }
            }
          } else {
            if (grid.isWalkableAt(x + dx, y)) {
              neighbors.push([x + dx, y]);
              if (!grid.isWalkableAt(x, y + 1)) {
                neighbors.push([x + dx, y + 1]);
              }
              if (!grid.isWalkableAt(x, y - 1)) {
                neighbors.push([x + dx, y - 1]);
              }
            }
          }
        }
      } else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
        for (i = 0, l = neighborNodes.length; i < l; ++i) {
          neighborNode = neighborNodes[i];
          neighbors.push([neighborNode.x, neighborNode.y]);
        }
      }
      return neighbors;
    };
    module.exports = JPFMoveDiagonallyIfAtMostOneObstacle;
  }
});

// node_modules/pathfinding/src/finders/JumpPointFinder.js
var require_JumpPointFinder = __commonJS({
  "node_modules/pathfinding/src/finders/JumpPointFinder.js"(exports, module) {
    var DiagonalMovement = require_DiagonalMovement();
    var JPFNeverMoveDiagonally = require_JPFNeverMoveDiagonally();
    var JPFAlwaysMoveDiagonally = require_JPFAlwaysMoveDiagonally();
    var JPFMoveDiagonallyIfNoObstacles = require_JPFMoveDiagonallyIfNoObstacles();
    var JPFMoveDiagonallyIfAtMostOneObstacle = require_JPFMoveDiagonallyIfAtMostOneObstacle();
    function JumpPointFinder(opt) {
      opt = opt || {};
      if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
      } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
      } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
      } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
      }
    }
    module.exports = JumpPointFinder;
  }
});

// node_modules/pathfinding/src/PathFinding.js
var require_PathFinding = __commonJS({
  "node_modules/pathfinding/src/PathFinding.js"(exports, module) {
    module.exports = {
      "Heap": require_heap2(),
      "Node": require_Node(),
      "Grid": require_Grid(),
      "Util": require_Util(),
      "DiagonalMovement": require_DiagonalMovement(),
      "Heuristic": require_Heuristic(),
      "AStarFinder": require_AStarFinder(),
      "BestFirstFinder": require_BestFirstFinder(),
      "BreadthFirstFinder": require_BreadthFirstFinder(),
      "DijkstraFinder": require_DijkstraFinder(),
      "BiAStarFinder": require_BiAStarFinder(),
      "BiBestFirstFinder": require_BiBestFirstFinder(),
      "BiBreadthFirstFinder": require_BiBreadthFirstFinder(),
      "BiDijkstraFinder": require_BiDijkstraFinder(),
      "IDAStarFinder": require_IDAStarFinder(),
      "JumpPointFinder": require_JumpPointFinder()
    };
  }
});

// node_modules/pathfinding/index.js
var require_pathfinding = __commonJS({
  "node_modules/pathfinding/index.js"(exports, module) {
    module.exports = require_PathFinding();
  }
});
export default require_pathfinding();
//# sourceMappingURL=pathfinding.js.map
